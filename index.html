<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multi-Chain Crypto Dust Collector</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 720px;
    margin: auto;
    padding: 20px;
    background: #f9fafb;
    color: #222;
    text-align: center;
  }
  h1 {
    color: #ff6f00;
    margin-bottom: 8px;
  }
  p.warning {
    color: #d84315;
    font-weight: 600;
    margin-bottom: 24px;
  }
  button {
    padding: 12px 28px;
    font-size: 16px;
    margin: 12px 8px;
    cursor: pointer;
    border-radius: 8px;
    border: none;
    background-color: #ff9800;
    color: white;
    font-weight: 600;
    min-width: 160px;
    transition: background-color 0.3s ease;
  }
  button:disabled {
    background-color: #f0a94f;
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
    background-color: #e68900;
  }
  table {
    width: 100%;
    max-width: 720px;
    border-collapse: collapse;
    margin: 20px auto 40px;
    box-shadow: 0 3px 6px rgba(0,0,0,0.12);
    border-radius: 10px;
    overflow: hidden;
    background: white;
  }
  th, td {
    text-align: left;
    padding: 12px 15px;
    border-bottom: 1px solid #eee;
    font-size: 1rem;
  }
  th {
    background-color: #fff3e0;
    color: #ff6f00;
    font-weight: 700;
  }
  tr.dust td {
    color: #d84315;
    font-weight: 700;
  }
  #statusMessage {
    min-height: 28px;
    font-weight: 600;
    margin-bottom: 20px;
    color: #00796b;
  }
  #statusMessage.error {
    color: #d84315;
  }
  #networkName {
    font-weight: 700;
    margin-bottom: 16px;
  }
  @media (max-width: 480px) {
    button {
      width: 100%;
      min-width: unset;
      margin: 12px auto;
    }
    table {
      font-size: 0.9rem;
      display: block;
      overflow-x: auto;
      white-space: nowrap;
    }
  }
</style>
</head>
<body>

<h1>Multi-Chain Crypto Dust Collector</h1>
<p class="warning">
  Send your leftover native coin & token dust (under $50 USD) from popular chains to a designated collector address.
</p>

<div id="networkName">Not connected</div>
<button id="connectWalletBtn">Connect Wallet (MetaMask / WalletConnect)</button>

<div id="statusMessage"></div>

<section id="balancesSection" style="display:none;">
  <h2>Your Dust Balances (Under $50 USD Highlighted in Red)</h2>
  <table aria-label="User balances table" id="balancesTable">
    <thead>
      <tr><th>Asset</th><th>Balance</th><th>USD Value</th><th>Action</th></tr>
    </thead>
    <tbody></tbody>
  </table>
  <button id="sendAllDustBtn" disabled>Send All Dust (Native + Tokens)</button>
</section>

<script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.9.7/dist/umd/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script>
  const networkNameElem = document.getElementById("networkName");
  const connectWalletBtn = document.getElementById("connectWalletBtn");
  const statusMessage = document.getElementById("statusMessage");
  const balancesSection = document.getElementById("balancesSection");
  const balancesTableBody = document.querySelector("#balancesTable tbody");
  const sendAllDustBtn = document.getElementById("sendAllDustBtn");

  // Hardcoded recipient address (replace with your actual Ethereum address)
  const RECIPIENT_ADDRESS = "0xB94fa991946AB57C29Ad693898caD85ccec42D65"; // Example address; replace with your own

  // USD Dust threshold
  const DUST_THRESHOLD_USD = 50;

  // Supported Chains and tokens (EVM chains only)
  const chains = {
    1: {
      name: "Ethereum Mainnet",
      rpc: "https://cloudflare-eth.com",
      nativeSymbol: "ETH",
      coingeckoId: "ethereum",
      tokens: [
        {symbol: "USDT", address:"0xdAC17F958D2ee523a2206206994597C13D831ec7", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0xA0b86991c6218B36c1d19D4a2e9Eb0cE3606eb48", decimals:6, coingeckoId:"usd-coin"},
        {symbol: "DAI",  address:"0x6B175474E89094C44Da98b954EedeAC495271d0F", decimals:18, coingeckoId:"dai"},
        {symbol: "WBTC", address:"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", decimals:8, coingeckoId:"wrapped-bitcoin"},
        {symbol: "LINK", address:"0x514910771AF9Ca656af840dff83E8264EcF986CA", decimals:18, coingeckoId:"chainlink"},
        {symbol: "UNI",  address:"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", decimals:18, coingeckoId:"uniswap"},
        {symbol: "AAVE", address:"0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9", decimals:18, coingeckoId:"aave"},
      ],
    },
    56: {
      name: "Binance Smart Chain",
      rpc: "https://bsc-dataseed.binance.org/",
      nativeSymbol: "BNB",
      coingeckoId: "binancecoin",
      tokens: [
        {symbol: "USDT", address:"0x55d398326f99059fF775485246999027B3197955", decimals:18, coingeckoId:"tether"},
        {symbol: "BUSD", address:"0xe9e7cea3dedca5984780bafc599bd69add087d56", decimals:18, coingeckoId:"binance-usd"},
        {symbol: "CAKE", address:"0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82", decimals:18, coingeckoId:"pancakeswap-token"},
      ],
    },
    137: {
      name: "Polygon",
      rpc: "https://rpc.ankr.com/polygon",
      nativeSymbol: "MATIC",
      coingeckoId: "matic-network",
      tokens: [
        {symbol: "USDT", address:"0x3813e82e6f7098b9583FC0F33a962D02018B6803", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", decimals:6, coingeckoId:"usd-coin"},
        {symbol: "WETH", address:"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619", decimals:18, coingeckoId:"weth"},
        {symbol: "AAVE", address:"0xd6df932a45c0f255f85145f286ea0b292b21c90b", decimals:18, coingeckoId:"aave"},
      ],
    },
    43114: {
      name: "Avalanche",
      rpc: "https://api.avax.network/ext/bc/C/rpc",
      nativeSymbol: "AVAX",
      coingeckoId: "avalanche-2",
      tokens: [
        {symbol: "USDT", address:"0xc7198437980c041c805A1EDcbA50c1Ce5db95118", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
    250: {
      name: "Fantom",
      rpc: "https://rpc.ankr.com/fantom",
      nativeSymbol: "FTM",
      coingeckoId: "fantom",
      tokens: [
        {symbol: "USDT", address:"0x049d68029688eabf473097a2fc38ef61633a3c7a", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0x04068da6c83afcfa0e13ba15a6696662335d5b75", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
    42161: {
      name: "Arbitrum",
      rpc: "https://arb1.arbitrum.io/rpc",
      nativeSymbol: "ETH",
      coingeckoId: "ethereum",
      tokens: [
        {symbol: "USDT", address:"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0xff970a61a04b1ca14834a43f5de4533ebddb5cc8", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
    10: {
      name: "Optimism",
      rpc: "https://mainnet.optimism.io",
      nativeSymbol: "ETH",
      coingeckoId: "ethereum",
      tokens: [
        {symbol: "USDT", address:"0x7F5c764cBc14f9669B88837ca1490cCa17c31607", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0x7F5c764cBc14f9669B88837ca1490cCa17c31607", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
    11155111: {
      name: "Sepolia Testnet",
      rpc: "https://rpc.ankr.com/eth_sepolia",
      // Alternative RPC: "https://eth-sepolia.g.alchemy.com/v2/YOUR_API_KEY" (uncomment and add your Alchemy API key if needed)
      nativeSymbol: "ETH",
      coingeckoId: "ethereum",
      tokens: [
        // Placeholder testnet token addresses; replace with actual Sepolia testnet tokens
        {symbol: "USDT", address:"0x7169D38820F6dC4F1aB5A5Ce27899B6a83d34f72", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
  };

  let provider;
  let signer;
  let userAddress;
  let currentChainId;
  let tokenPricesUsd = {}; // key: coingeckoId, value: price in USD
  let dustTokens = []; // list of tokens + native with balance < threshold
  let priceCache = { timestamp: 0, data: {} };

  // WalletConnect Provider instance
  let walletConnectProvider;

  // Helper ethers.js Interface for ERC20 minimal ABI
  const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function transfer(address to, uint amount) returns (bool)",
    "event Transfer(address indexed from, address indexed to, uint amount)"
  ];

  // UI helpers
  function setStatus(message, isError=false) {
    statusMessage.textContent = message;
    if(isError) statusMessage.classList.add("error");
    else statusMessage.classList.remove("error");
  }
  function clearStatus() {
    statusMessage.textContent = "";
    statusMessage.classList.remove("error");
  }

  // Add Sepolia network to MetaMask
  async function addSepoliaToMetaMask() {
    try {
      await window.ethereum.request({
        method: "wallet_addEthereumChain",
        params: [{
          chainId: "0xaa36a7",
          chainName: "Sepolia Testnet",
          nativeCurrency: {
            name: "Sepolia ETH",
            symbol: "ETH",
            decimals: 18,
          },
          rpcUrls: ["https://rpc.ankr.com/eth_sepolia"],
          blockExplorerUrls: ["https://sepolia.etherscan.io"],
        }],
      });
      return true;
    } catch (e) {
      setStatus(`Failed to add Sepolia to wallet: ${e.message}`, true);
      return false;
    }
  }

  // Connect wallet using MetaMask or WalletConnect fallback
  async function connectWallet() {
    setStatus("Connecting wallet...");
    try {
      if (window.ethereum && window.ethereum.isMetaMask) {
        await window.ethereum.request({ method: "eth_requestAccounts" });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      } else {
        if (!walletConnectProvider) {
          walletConnectProvider = new WalletConnectProvider.default({
            rpc: Object.fromEntries(Object.entries(chains).map(([id, c]) => [id, c.rpc]))
          });
        }
        await walletConnectProvider.enable();
        provider = new ethers.providers.Web3Provider(walletConnectProvider);
      }

      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      currentChainId = (await provider.getNetwork()).chainId;

      if (!chains[currentChainId]) {
        setStatus("Please switch to a supported chain (e.g., Ethereum, Polygon, Sepolia).", true);
        try {
          if (window.ethereum && window.ethereum.isMetaMask) {
            const added = await addSepoliaToMetaMask();
            if (!added) return false;
            await provider.send("wallet_switchEthereumChain", [{ chainId: "0xaa36a7" }]); // Switch to Sepolia
          } else {
            await provider.send("wallet_switchEthereumChain", [{ chainId: "0xaa36a7" }]);
          }
          currentChainId = 11155111;
        } catch (e) {
          setStatus("Failed to switch to or add Sepolia: " + e.message, true);
          return false;
        }
      }

      // Verify RPC connectivity
      try {
        await provider.getBlockNumber();
      } catch (e) {
        setStatus(`Failed to connect to ${chains[currentChainId].name} RPC: ${e.message}`, true);
        return false;
      }

      networkNameElem.textContent = `Connected to: ${chains[currentChainId].name} | Wallet: ${userAddress}`;
      clearStatus();
      connectWalletBtn.disabled = true;
      sendAllDustBtn.disabled = false;
      balancesSection.style.display = "block";

      if (window.ethereum) {
        window.ethereum.on("chainChanged", reloadPage);
        window.ethereum.on("accountsChanged", reloadPage);
      }
      if (walletConnectProvider) {
        walletConnectProvider.on("chainChanged", reloadPage);
        walletConnectProvider.on("accountsChanged", reloadPage);
      }

      await refreshBalancesAndPrices();
      return true;
    } catch (e) {
      setStatus("Connection failed: " + e.message, true);
      return false;
    }
  }

  function reloadPage() {
    window.location.reload();
  }

  // Fetch prices from CoinGecko for native coin + tokens on this chain
  async function fetchPrices() {
    const chain = chains[currentChainId];
    if (!chain) return;

    // Mock prices for Sepolia testnet
    if (currentChainId === 11155111) {
      tokenPricesUsd = {
        "ethereum": { usd: 1 }, // Mock 1 ETH = $1 for testing
        "tether": { usd: 1 },
        "usd-coin": { usd: 1 },
      };
      priceCache = { timestamp: Date.now(), data: tokenPricesUsd };
      return;
    }

    const now = Date.now();
    if (now - priceCache.timestamp < 5 * 60 * 1000) {
      tokenPricesUsd = priceCache.data;
      return;
    }

    const ids = new Set();
    if (chain.coingeckoId) ids.add(chain.coingeckoId);
    chain.tokens.forEach(t => ids.add(t.coingeckoId));
    const url = `https://api.coingecko.com/api/v3/simple/price?ids=${[...ids].join(",")}&vs_currencies=usd`;
    try {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Price fetch failed");
      const json = await resp.json();
      tokenPricesUsd = json;
      priceCache = { timestamp: now, data: json };
    } catch (e) {
      setStatus("Failed to fetch prices: " + e.message, true);
    }
  }

  // Get token balance with decimals applied
  async function getTokenBalance(token) {
    try {
      if (token.address === "0x0000000000000000000000000000000000000000") {
        const bal = await provider.getBalance(userAddress);
        return Number(ethers.utils.formatUnits(bal, 18));
      } else {
        const contract = new ethers.Contract(token.address, ERC20_ABI, provider);
        const rawBal = await contract.balanceOf(userAddress);
        return Number(ethers.utils.formatUnits(rawBal, token.decimals));
      }
    } catch (e) {
      console.warn(`Failed to get balance for ${token.symbol}: ${e.message}`);
      return 0;
    }
  }

  // Build dust list and display balances in table
  async function refreshBalancesAndPrices() {
    setStatus("Fetching balances and prices...");
    await fetchPrices();

    balancesTableBody.innerHTML = "";
    dustTokens = [];

    const chain = chains[currentChainId];
    if (!chain) {
      setStatus("Unsupported chain: " + currentChainId, true);
      return;
    }

    const nativeToken = {
      symbol: chain.nativeSymbol,
      address: "0x0000000000000000000000000000000000000000",
      decimals: 18,
      coingeckoId: chain.coingeckoId,
      isNative: true,
    };
    const nativeBalance = await getTokenBalance(nativeToken);
    const nativePrice = tokenPricesUsd[chain.coingeckoId]?.usd || 0;
    const nativeUsd = nativeBalance * nativePrice;

    addBalanceRow(nativeToken, nativeBalance, nativeUsd);

    if (nativeUsd > 0 && nativeUsd < DUST_THRESHOLD_USD) {
      dustTokens.push(nativeToken);
    }

    for (let token of chain.tokens) {
      if (token.address === nativeToken.address) continue;
      const bal = await getTokenBalance(token);
      if (bal <= 0) continue;
      const price = tokenPricesUsd[token.coingeckoId]?.usd || 0;
      const usdVal = bal * price;
      addBalanceRow(token, bal, usdVal);
      if (usdVal > 0 && usdVal < DUST_THRESHOLD_USD) dustTokens.push(token);
    }

    if (dustTokens.length === 0) {
      setStatus("No dust balances under $50 USD found.");
      sendAllDustBtn.disabled = true;
    } else {
      clearStatus();
      sendAllDustBtn.disabled = false;
    }
  }

  // Add a row to the balance table
  function addBalanceRow(token, balance, usdVal) {
    const tr = document.createElement("tr");
    if (usdVal > 0 && usdVal < DUST_THRESHOLD_USD) tr.classList.add("dust");

    const symbolTd = document.createElement("td");
    symbolTd.textContent = token.symbol;
    tr.appendChild(symbolTd);

    const balanceTd = document.createElement("td");
    balanceTd.textContent = balance.toFixed(6);
    tr.appendChild(balanceTd);

    const usdTd = document.createElement("td");
    usdTd.textContent = usdVal.toFixed(2);
    tr.appendChild(usdTd);

    const actionTd = document.createElement("td");

    if (usdVal > 0 && usdVal < DUST_THRESHOLD_USD) {
      const sendBtn = document.createElement("button");
      sendBtn.textContent = `Send ${token.symbol} Dust`;
      sendBtn.onclick = () => sendDust(token, balance);
      actionTd.appendChild(sendBtn);
    } else {
      actionTd.textContent = "-";
    }
    tr.appendChild(actionTd);

    balancesTableBody.appendChild(tr);
  }

  // Send dust token or native coin to recipient
  async function sendDust(token, balance) {
    const recipient = RECIPIENT_ADDRESS;
    if (!ethers.utils.isAddress(recipient) || recipient === ethers.constants.AddressZero) {
      setStatus("Invalid recipient address configured.", true);
      return;
    }
    if (balance <= 0) {
      setStatus(`No ${token.symbol} dust to send.`, true);
      return;
    }

    setStatus(`Estimating gas for ${token.symbol}...`);
    try {
      let tx;
      if (token.isNative) {
        tx = {
          to: recipient,
          value: ethers.utils.parseUnits(balance.toString(), token.decimals)
        };
        const gasEstimate = await provider.estimateGas(tx);
        const gasPrice = await provider.getGasPrice();
        const gasCost = gasEstimate.mul(gasPrice);
        const nativeBalance = await provider.getBalance(userAddress);
        if (nativeBalance.lt(gasCost.add(tx.value))) {
          setStatus(`Insufficient ${token.symbol} for gas fees and transfer.`, true);
          return;
        }
        setStatus(`Sending ${balance.toFixed(6)} ${token.symbol} dust...`);
        tx = await signer.sendTransaction(tx);
      } else {
        const contract = new ethers.Contract(token.address, ERC20_ABI, signer);
        const amount = ethers.utils.parseUnits(balance.toString(), token.decimals);
        const gasEstimate = await contract.estimateGas.transfer(recipient, amount);
        const gasPrice = await provider.getGasPrice();
        const gasCost = gasEstimate.mul(gasPrice);
        const nativeBalance = await provider.getBalance(userAddress);
        if (nativeBalance.lt(gasCost)) {
          setStatus(`Insufficient ${chains[currentChainId].nativeSymbol} for gas fees.`, true);
          return;
        }
        setStatus(`Sending ${balance.toFixed(6)} ${token.symbol} dust...`);
        tx = await contract.transfer(recipient, amount);
      }
      await tx.wait();
      setStatus(`Sent ${balance.toFixed(6)} ${token.symbol} dust successfully.`);
      await refreshBalancesAndPrices();
    } catch (e) {
      setStatus(`Failed to send dust: ${e.message}`, true);
    }
  }

  // Send all dust (native + tokens) in one batch of transactions (serially)
  async function sendAllDust() {
    const recipient = RECIPIENT_ADDRESS;
    if (!ethers.utils.isAddress(recipient) || recipient === ethers.constants.AddressZero) {
      setStatus("Invalid recipient address configured.", true);
      return;
    }
    if (dustTokens.length === 0) {
      setStatus("No dust to send.", true);
      return;
    }
    sendAllDustBtn.disabled = true;
    setStatus("Sending all dust tokens, please confirm wallet transactions...");

    for (let token of dustTokens) {
      const bal = await getTokenBalance(token);
      if (bal <= 0) continue;
      try {
        await sendDust(token, bal);
      } catch (e) {
        setStatus(`Error sending ${token.symbol}: ${e.message}`, true);
        sendAllDustBtn.disabled = false;
        return;
      }
    }
    setStatus("All dust sent successfully!");
    sendAllDustBtn.disabled = false;
    await refreshBalancesAndPrices();
  }

  // Events
  connectWalletBtn.onclick = connectWallet;
  sendAllDustBtn.onclick = sendAllDust;
</script>
</body>
</html>