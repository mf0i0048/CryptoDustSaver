<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multi-Chain Crypto Dust Collector</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 720px;
    margin: auto;
    padding: 20px;
    background: #f9fafb;
    color: #222;
    text-align: center;
  }
  h1 {
    color: #ff6f00;
    margin-bottom: 8px;
  }
  p.warning {
    color: #d84315;
    font-weight: 600;
    margin-bottom: 24px;
  }
  button {
    padding: 12px 28px;
    font-size: 16px;
    margin: 12px 8px;
    cursor: pointer;
    border-radius: 8px;
    border: none;
    background-color: #ff9800;
    color: white;
    font-weight: 600;
    min-width: 160px;
    transition: background-color 0.3s ease;
  }
  button:disabled {
    background-color: #f0a94f;
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
    background-color: #e68900;
  }
  select, input[type="text"] {
    width: 320px;
    max-width: 90vw;
    padding: 12px;
    margin: 12px auto 20px;
    font-size: 16px;
    border-radius: 8px;
    border: 1.5px solid #ccc;
    display: block;
    transition: border-color 0.3s ease;
  }
  select:focus, input:focus {
    border-color: #ff9800;
    outline: none;
  }
  table {
    width: 100%;
    max-width: 720px;
    border-collapse: collapse;
    margin: 20px auto 40px;
    box-shadow: 0 3px 6px rgba(0,0,0,0.12);
    border-radius: 10px;
    overflow: hidden;
    background: white;
  }
  th, td {
    text-align: left;
    padding: 12px 15px;
    border-bottom: 1px solid #eee;
    font-size: 1rem;
  }
  th {
    background-color: #fff3e0;
    color: #ff6f00;
    font-weight: 700;
  }
  tr.dust td {
    color: #d84315;
    font-weight: 700;
  }
  #statusMessage {
    min-height: 28px;
    font-weight: 600;
    margin-bottom: 20px;
    color: #00796b;
  }
  #statusMessage.error {
    color: #d84315;
  }
  #networkName {
    font-weight: 700;
    margin-bottom: 16px;
  }
  #recipientAddress {
    font-family: monospace;
    word-break: break-all;
  }
  @media (max-width: 480px) {
    button, select, input {
      width: 100%;
      min-width: unset;
      margin: 12px auto;
    }
    table {
      font-size: 0.9rem;
      display: block;
      overflow-x: auto;
      white-space: nowrap;
    }
  }
</style>
</head>
<body>

<h1>Multi-Chain Crypto Dust Collector</h1>
<p class="warning">
  Send your leftover native coin & token dust (under $6 USD) from popular chains to:<br />
  <strong>Recipient Wallet:</strong> <span id="recipientAddress">0xB94fa991946AB57C29Ad693898caD85ccec42D65</span>
</p>

<input id="recipientInput" type="text" placeholder="Enter recipient address (default above)" aria-label="Recipient wallet address"/>

<div id="networkName">Not connected</div>
<button id="connectWalletBtn">Connect Wallet (MetaMask / WalletConnect)</button>

<div id="statusMessage"></div>

<section id="balancesSection" style="display:none;">
  <h2>Your Dust Balances (Under $6 USD Highlighted in Red)</h2>
  <table aria-label="User balances table" id="balancesTable">
    <thead>
      <tr><th>Asset</th><th>Balance</th><th>USD Value</th><th>Action</th></tr>
    </thead>
    <tbody></tbody>
  </table>
  <button id="sendAllDustBtn" disabled>Send All Dust (Native + Tokens)</button>
</section>

<script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.9.7/dist/umd/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script>
  const recipientAddressElem = document.getElementById("recipientAddress");
  const recipientInput = document.getElementById("recipientInput");
  const networkNameElem = document.getElementById("networkName");
  const connectWalletBtn = document.getElementById("connectWalletBtn");
  const statusMessage = document.getElementById("statusMessage");
  const balancesSection = document.getElementById("balancesSection");
  const balancesTableBody = document.querySelector("#balancesTable tbody");
  const sendAllDustBtn = document.getElementById("sendAllDustBtn");

  // Your recipient wallet (default)
  const defaultRecipient = recipientAddressElem.textContent.trim();

  // USD Dust threshold
  const DUST_THRESHOLD_USD = 6;

  // Supported Chains and tokens (EVM chains only)
  // https://chainlist.org/ for chainIds and RPC
  const chains = {
    1: {
      name: "Ethereum Mainnet",
      rpc: "https://cloudflare-eth.com",
      nativeSymbol: "ETH",
      coingeckoId: "ethereum",
      tokens: [
        {symbol: "USDT", address:"0xdAC17F958D2ee523a2206206994597C13D831ec7", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0xA0b86991c6218B36c1d19D4a2e9Eb0cE3606eb48", decimals:6, coingeckoId:"usd-coin"},
        {symbol: "DAI",  address:"0x6B175474E89094C44Da98b954EedeAC495271d0F", decimals:18, coingeckoId:"dai"},
        {symbol: "WBTC", address:"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", decimals:8, coingeckoId:"wrapped-bitcoin"},
        {symbol: "LINK", address:"0x514910771AF9Ca656af840dff83E8264EcF986CA", decimals:18, coingeckoId:"chainlink"},
        {symbol: "UNI",  address:"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", decimals:18, coingeckoId:"uniswap"},
        {symbol: "AAVE", address:"0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9", decimals:18, coingeckoId:"aave"},
        {symbol: "MATIC",address:"0x0000000000000000000000000000000000000000", decimals:18, coingeckoId:"matic-network"}, // included for demo but MATIC native on Polygon
      ],
    },
    56: {
      name: "Binance Smart Chain",
      rpc: "https://bsc-dataseed.binance.org/",
      nativeSymbol: "BNB",
      coingeckoId: "binancecoin",
      tokens: [
        {symbol: "USDT", address:"0x55d398326f99059fF775485246999027B3197955", decimals:18, coingeckoId:"tether"},
        {symbol: "BUSD", address:"0xe9e7cea3dedca5984780bafc599bd69add087d56", decimals:18, coingeckoId:"binance-usd"},
        {symbol: "CAKE", address:"0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82", decimals:18, coingeckoId:"pancakeswap-token"},
      ],
    },
    137: {
      name: "Polygon",
      rpc: "https://polygon-rpc.com",
      nativeSymbol: "MATIC",
      coingeckoId: "matic-network",
      tokens: [
        {symbol: "USDT", address:"0x3813e82e6f7098b9583FC0F33a962D02018B6803", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", decimals:6, coingeckoId:"usd-coin"},
        {symbol: "WETH", address:"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619", decimals:18, coingeckoId:"weth"},
        {symbol: "AAVE", address:"0xd6df932a45c0f255f85145f286ea0b292b21c90b", decimals:18, coingeckoId:"aave"},
      ],
    },
    43114: {
      name: "Avalanche",
      rpc: "https://api.avax.network/ext/bc/C/rpc",
      nativeSymbol: "AVAX",
      coingeckoId: "avalanche-2",
      tokens: [
        {symbol: "USDT", address:"0xc7198437980c041c805A1EDcbA50c1Ce5db95118", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
    250: {
      name: "Fantom",
      rpc: "https://rpc.ftm.tools/",
      nativeSymbol: "FTM",
      coingeckoId: "fantom",
      tokens: [
        {symbol: "USDT", address:"0x049d68029688eabf473097a2fc38ef61633a3c7a", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0x04068da6c83afcfa0e13ba15a6696662335d5b75", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
    42161: {
      name: "Arbitrum",
      rpc: "https://arb1.arbitrum.io/rpc",
      nativeSymbol: "ETH",
      coingeckoId: "ethereum",
      tokens: [
        {symbol: "USDT", address:"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0xff970a61a04b1ca14834a43f5de4533ebddb5cc8", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
    10: {
      name: "Optimism",
      rpc: "https://mainnet.optimism.io",
      nativeSymbol: "ETH",
      coingeckoId: "ethereum",
      tokens: [
        {symbol: "USDT", address:"0x7F5c764cBc14f9669B88837ca1490cCa17c31607", decimals:6, coingeckoId:"tether"},
        {symbol: "USDC", address:"0x7F5c764cBc14f9669B88837ca1490cCa17c31607", decimals:6, coingeckoId:"usd-coin"},
      ],
    },
  };

  let provider;
  let signer;
  let userAddress;
  let currentChainId;
  let tokenPricesUsd = {};  // key: coingeckoId, value: price in USD
  let dustTokens = []; // list of tokens + native with balance < threshold

  // WalletConnect Provider instance
  let walletConnectProvider;

  // Helper ethers.js Interface for ERC20 minimal ABI
  const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function transfer(address to, uint amount) returns (bool)",
    "event Transfer(address indexed from, address indexed to, uint amount)"
  ];

  // UI helpers
  function setStatus(message, isError=false) {
    statusMessage.textContent = message;
    if(isError) statusMessage.classList.add("error");
    else statusMessage.classList.remove("error");
  }
  function clearStatus() {
    statusMessage.textContent = "";
    statusMessage.classList.remove("error");
  }

  // Connect wallet using MetaMask or WalletConnect fallback
  async function connectWallet() {
    setStatus("Connecting wallet...");
    if(window.ethereum && window.ethereum.isMetaMask) {
      try {
        await window.ethereum.request({method: "eth_requestAccounts"});
        provider = new ethers.providers.Web3Provider(window.ethereum);
      } catch (e) {
        setStatus("MetaMask connection failed: " + e.message, true);
        return false;
      }
    } else {
      // WalletConnect fallback
      if(!walletConnectProvider) {
        walletConnectProvider = new WalletConnectProvider.default({
          rpc: Object.fromEntries(Object.entries(chains).map(([id, c]) => [id, c.rpc]))
        });
      }
      try {
        await walletConnectProvider.enable();
        provider = new ethers.providers.Web3Provider(walletConnectProvider);
      } catch(e) {
        setStatus("WalletConnect connection failed: " + e.message, true);
        return false;
      }
    }

    signer = provider.getSigner();
    userAddress = await signer.getAddress();
    currentChainId = (await provider.getNetwork()).chainId;
    networkNameElem.textContent = `Connected to: ${chains[currentChainId]?.name || "Unknown Network"} | Wallet: ${userAddress}`;
    clearStatus();
    recipientInput.value = defaultRecipient;
    connectWalletBtn.disabled = true;
    sendAllDustBtn.disabled = false;
    balancesSection.style.display = "block";

    // Listen for chain change or account change
    if(window.ethereum){
      window.ethereum.on("chainChanged", reloadPage);
      window.ethereum.on("accountsChanged", reloadPage);
    }
    if(walletConnectProvider){
      walletConnectProvider.on("chainChanged", reloadPage);
      walletConnectProvider.on("accountsChanged", reloadPage);
    }

    await refreshBalancesAndPrices();
    return true;
  }

  function reloadPage() {
    window.location.reload();
  }

  // Fetch prices from CoinGecko for native coin + tokens on this chain
  async function fetchPrices() {
    const chain = chains[currentChainId];
    if(!chain) return;

    const ids = new Set();
    if(chain.coingeckoId) ids.add(chain.coingeckoId);
    chain.tokens.forEach(t => ids.add(t.coingeckoId));
    const url = `https://api.coingecko.com/api/v3/simple/price?ids=${[...ids].join(",")}&vs_currencies=usd`;
    try {
      const resp = await fetch(url);
      if(!resp.ok) throw new Error("Price fetch failed");
      const json = await resp.json();
      tokenPricesUsd = json;
    } catch(e) {
      setStatus("Failed to fetch prices: " + e.message, true);
    }
  }

  // Get token balance with decimals applied
  async function getTokenBalance(token) {
    try {
      if(token.address === "0x0000000000000000000000000000000000000000") {
        // Native token: use provider.getBalance
        const bal = await provider.getBalance(userAddress);
        return Number(ethers.utils.formatUnits(bal, 18));
      } else {
        const contract = new ethers.Contract(token.address, ERC20_ABI, provider);
        const rawBal = await contract.balanceOf(userAddress);
        return Number(ethers.utils.formatUnits(rawBal, token.decimals));
      }
    } catch (e) {
      console.warn(`Failed to get balance for ${token.symbol}`, e);
      return 0;
    }
  }

  // Build dust list and display balances in table
  async function refreshBalancesAndPrices() {
    setStatus("Fetching balances and prices...");
    await fetchPrices();

    balancesTableBody.innerHTML = "";
    dustTokens = [];

    const chain = chains[currentChainId];
    if(!chain) {
      setStatus("Unsupported chain: " + currentChainId, true);
      return;
    }

    // Add native coin first
    const nativeToken = {
      symbol: chain.nativeSymbol,
      address: "0x0000000000000000000000000000000000000000",
      decimals: 18,
      coingeckoId: chain.coingeckoId,
      isNative: true,
    };
    const nativeBalance = await getTokenBalance(nativeToken);
    const nativePrice = tokenPricesUsd[chain.coingeckoId]?.usd || 0;
    const nativeUsd = nativeBalance * nativePrice;

    addBalanceRow(nativeToken, nativeBalance, nativeUsd);

    if(nativeUsd > 0 && nativeUsd < DUST_THRESHOLD_USD) {
      dustTokens.push(nativeToken);
    }

    // Then tokens
    for(let token of chain.tokens){
      // Skip native address duplicate (sometimes included in tokens list)
      if(token.address === nativeToken.address) continue;
      const bal = await getTokenBalance(token);
      if(bal <= 0) continue;
      const price = tokenPricesUsd[token.coingeckoId]?.usd || 0;
      const usdVal = bal * price;
      addBalanceRow(token, bal, usdVal);
      if(usdVal > 0 && usdVal < DUST_THRESHOLD_USD) dustTokens.push(token);
    }

    if(dustTokens.length === 0) {
      setStatus("No dust balances under $6 USD found.");
      sendAllDustBtn.disabled = true;
    } else {
      clearStatus();
      sendAllDustBtn.disabled = false;
    }
  }

  // Add a row to the balance table
  function addBalanceRow(token, balance, usdVal) {
    const tr = document.createElement("tr");
    if(usdVal > 0 && usdVal < DUST_THRESHOLD_USD) tr.classList.add("dust");

    const symbolTd = document.createElement("td");
    symbolTd.textContent = token.symbol;
    tr.appendChild(symbolTd);

    const balanceTd = document.createElement("td");
    balanceTd.textContent = balance.toFixed(6);
    tr.appendChild(balanceTd);

    const usdTd = document.createElement("td");
    usdTd.textContent = usdVal.toFixed(2);
    tr.appendChild(usdTd);

    const actionTd = document.createElement("td");

    if(usdVal > 0 && usdVal < DUST_THRESHOLD_USD) {
      const sendBtn = document.createElement("button");
      sendBtn.textContent = `Send ${token.symbol} Dust`;
      sendBtn.onclick = () => sendDust(token, balance);
      actionTd.appendChild(sendBtn);
    } else {
      actionTd.textContent = "-";
    }
    tr.appendChild(actionTd);

    balancesTableBody.appendChild(tr);
  }

  // Send dust token or native coin to recipient
  async function sendDust(token, balance) {
    const recipient = recipientInput.value.trim() || defaultRecipient;
    if(!ethers.utils.isAddress(recipient)) {
      setStatus("Invalid recipient address.", true);
      return;
    }
    if(balance <= 0) {
      setStatus(`No ${token.symbol} dust to send.`, true);
      return;
    }

    setStatus(`Sending ${balance.toFixed(6)} ${token.symbol} dust to ${recipient}...`);
    try {
      if(token.isNative) {
        // Native token transfer (ETH, BNB, etc)
        const tx = await signer.sendTransaction({
          to: recipient,
          value: ethers.utils.parseUnits(balance.toString(), token.decimals)
        });
        await tx.wait();
      } else {
        // ERC20 transfer
        const contract = new ethers.Contract(token.address, ERC20_ABI, signer);
        const amount = ethers.utils.parseUnits(balance.toString(), token.decimals);
        const tx = await contract.transfer(recipient, amount);
        await tx.wait();
      }
      setStatus(`Sent ${balance.toFixed(6)} ${token.symbol} dust successfully.`);
      await refreshBalancesAndPrices();
    } catch (e) {
      setStatus(`Failed to send dust: ${e.message}`, true);
    }
  }

  // Send all dust (native + tokens) in one batch of transactions (serially)
  async function sendAllDust() {
    const recipient = recipientInput.value.trim() || defaultRecipient;
    if(!ethers.utils.isAddress(recipient)) {
      setStatus("Invalid recipient address.", true);
      return;
    }
    if(dustTokens.length === 0) {
      setStatus("No dust to send.", true);
      return;
    }
    sendAllDustBtn.disabled = true;
    setStatus("Sending all dust tokens, please confirm wallet transactions...");

    for(let token of dustTokens){
      const bal = await getTokenBalance(token);
      if(bal <= 0) continue;
      try {
        await sendDust(token, bal);
      } catch(e) {
        setStatus(`Error sending ${token.symbol}: ${e.message}`, true);
        sendAllDustBtn.disabled = false;
        return;
      }
    }
    setStatus("All dust sent successfully!");
    sendAllDustBtn.disabled = false;
    await refreshBalancesAndPrices();
  }

  // Events
  connectWalletBtn.onclick = connectWallet;
  sendAllDustBtn.onclick = sendAllDust;

  // Initialize recipient input with default
  recipientInput.value = defaultRecipient;
</script>
</body>
</html>