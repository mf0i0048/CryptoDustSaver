<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crypto Dust Saver</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-align: center;
      padding: 40px 20px;
      background-color: #f9fafb;
      color: #222;
      max-width: 700px;
      margin: auto;
    }
    h1 {
      margin-bottom: 5px;
      color: #ff6f00;
    }
    p.warning {
      color: #d84315;
      font-weight: 600;
      margin-top: 0;
      margin-bottom: 25px;
    }
    button {
      padding: 12px 28px;
      font-size: 16px;
      margin: 12px 8px;
      cursor: pointer;
      border-radius: 8px;
      border: none;
      background-color: #ff9800;
      color: white;
      transition: background-color 0.3s ease;
      min-width: 160px;
      font-weight: 600;
    }
    button:disabled {
      background-color: #f0a94f;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #e68900;
    }
    input,
    select {
      padding: 12px;
      font-size: 16px;
      margin: 12px auto 20px;
      border-radius: 8px;
      border: 1.5px solid #ccc;
      width: 320px;
      display: block;
      transition: border-color 0.3s ease;
    }
    input:focus,
    select:focus {
      border-color: #ff9800;
      outline: none;
    }
    table {
      margin: 0 auto 40px;
      border-collapse: collapse;
      width: 100%;
      max-width: 700px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.12);
      border-radius: 10px;
      overflow: hidden;
    }
    th,
    td {
      border-bottom: 1px solid #eee;
      padding: 12px 15px;
      text-align: left;
    }
    th {
      background-color: #fff3e0;
      font-weight: 700;
      font-size: 1rem;
      color: #ff6f00;
    }
    tr:last-child td {
      border-bottom: none;
    }
    tr.dust td {
      color: #d84315;
      font-weight: 700;
    }
    #balancesSection {
      margin-bottom: 40px;
    }
    #selectedTokenUsd {
      font-weight: 700;
      color: #333;
      margin-top: -15px;
      margin-bottom: 12px;
      font-size: 1rem;
      min-height: 24px;
    }
    #statusMessage {
      font-weight: 600;
      color: #00796b;
      min-height: 30px;
      margin-bottom: 20px;
    }
    #statusMessage.error {
      color: #d84315;
    }
    #recipientAddress {
      font-family: monospace;
      word-break: break-all;
    }
    #currentNetwork {
      margin-bottom: 20px;
      font-weight: 600;
    }
    @media (max-width: 480px) {
      input, select {
        width: 90%;
      }
      button {
        min-width: 100%;
        display: block;
        margin: 12px auto;
      }
      table {
        font-size: 0.9rem;
        display: block;
        overflow-x: auto;
        white-space: nowrap;
      }
    }
  </style>
</head>
<body>
  <h1>Donate Your Crypto Dust</h1>
  <p class="warning">
    Send your leftover ETH or token dust to support our project.<br />
    <strong>Warning:</strong> This sends your FULL balance for selected items
    (minus gas for ETH). Only use for small dust amounts!
  </p>
  <p>Donations are sent to: <span id="recipientAddress">0xB94fa991946AB57C29Ad693898caD85ccec42D65</span></p>
  <input
    id="recipientAddressInput"
    type="text"
    placeholder="Enter recipient address (default: 0xB94...)"
    aria-label="Recipient Address"
  />

  <div id="currentNetwork"></div>
  <button id="connectButton">Connect Wallet</button>

  <div id="statusMessage"></div>

  <div class="section" id="balancesSection" style="display: none;">
    <h2>Your Balances (Dust under $6 highlighted in red)</h2>
    <table id="balancesTable" aria-label="User crypto balances">
      <thead>
        <tr>
          <th>Asset</th>
          <th>Balance</th>
          <th>USD Equivalent</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="section">
    <button id="sendEthButton" disabled>Send ETH Dust</button>
    <button id="sendAllButton" disabled>Send All Dust Under $6</button>
  </div>

  <div class="section">
    <select id="tokenSelect" disabled aria-label="Select token to send dust">
      <option value="">Select Popular Token</option>
    </select>
    <div id="selectedTokenUsd"></div>
    <button id="sendTokenButton" disabled>Send Selected Token Dust</button>
  </div>

  <div class="section">
    <input
      id="customTokenAddress"
      type="text"
      placeholder="Enter Custom ERC-20 Address (e.g., 0x...)"
      disabled
      aria-label="Custom ERC-20 Token Address"
    />
    <button id="sendCustomTokenButton" disabled>Send Custom Token Dust</button>
  </div>

  <script>
    const connectButton = document.getElementById("connectButton");
    const sendEthButton = document.getElementById("sendEthButton");
    const sendAllButton = document.getElementById("sendAllButton");
    const tokenSelect = document.getElementById("tokenSelect");
    const sendTokenButton = document.getElementById("sendTokenButton");
    const customTokenAddress = document.getElementById("customTokenAddress");
    const sendCustomTokenButton = document.getElementById("sendCustomTokenButton");
    const balancesTableBody = document
      .getElementById("balancesTable")
      .querySelector("tbody");
    const balancesSection = document.getElementById("balancesSection");
    const selectedTokenUsd = document.getElementById("selectedTokenUsd");
    const statusMessage = document.getElementById("statusMessage");
    const myWalletAddress = "0xB94fa991946AB57C29Ad693898caD85ccec42D65";

    let userAccount = null;
    let pricesUsd = {};
    let ethPriceUsd = 0;
    let lastPriceFetch = 0;
    const priceCacheDuration = 5 * 60 * 1000; // 5 minutes

    const dustThresholdUSD = 6; // USD dust threshold

    // Map token symbols to CoinGecko IDs
    const tokenPriceMap = {
      eth: "ethereum",
      usdt: "tether",
      usdc: "usd-coin",
      wbtc: "wrapped-bitcoin",
      link: "chainlink",
      usde: "stableusd",
      dai: "dai",
      uni: "uniswap",
      shib: "shiba-inu",
      pepe: "pepe",
      aave: "aave",
      mkr: "maker",
      grt: "the-graph",
      ldo: "lido-dao",
      matic: "matic-network",
      ape: "apecoin",
    };

    const popularTokens = [
      { symbol: "USDT", address: "0xdac17f958d2ee523a2206206994597c13d831ec7" },
      { symbol: "USDC", address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" },
      { symbol: "WBTC", address: "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599" },
      { symbol: "LINK", address: "0x514910771af9ca656af840dff83e8264ecf986ca" },
      { symbol: "USDe", address: "0x4c9edd5852cd905f086c759e8383e09bff1e68b3" },
      { symbol: "DAI", address: "0x6b175474e89094c44da98b954eedeac495271d0f" },
      { symbol: "UNI", address: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984" },
      { symbol: "SHIB", address: "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce" },
      { symbol: "PEPE", address: "0x6982508145454ce325ddbeb138e4e3d49a8720c0" },
      { symbol: "AAVE", address: "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9" },
      { symbol: "MKR", address: "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2" },
      { symbol: "GRT", address: "0xc944e90c64b2c07662a292be6244bdf05cda44a7" },
      { symbol: "LDO", address: "0x5a98fcbea516cf06857215779fd812ca3bef1b32" },
      { symbol: "MATIC", address: "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0" },
      { symbol: "APE", address: "0x4d224452801aced8b2f0aebe155379bb5d594381" },
    ];

    popularTokens.forEach((token) => {
      const option = document.createElement("option");
      option.value = token.address;
      option.textContent = token.symbol;
      tokenSelect.appendChild(option);
    });

    function showError(message) {
      statusMessage.innerText = message;
      statusMessage.classList.add("error");
    }

    function clearStatus() {
      statusMessage.innerText = "";
      statusMessage.classList.remove("error");
    }

    function disableAll(disable) {
      sendEthButton.disabled = disable;
      sendAllButton.disabled = disable;
      sendTokenButton.disabled = disable;
      sendCustomTokenButton.disabled = disable;
      tokenSelect.disabled = disable;
      customTokenAddress.disabled = disable;
    }

    async function fetchPrices(maxRetries = 3) {
      if (Date.now() - lastPriceFetch < priceCacheDuration) return;
      const chainId = await ethereum.request({ method: "eth_chainId" });
      if (chainId !== "0x1") {
        showError("Warning: Token prices may be unavailable on this network.");
      }
      for (let i = 0; i < maxRetries; i++) {
        try {
          const ids = Object.values(tokenPriceMap).join(",");
          const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`;
          const response = await fetch(url);
          if (!response.ok) throw new Error("API error");
          const data = await response.json();
          for (const [symbol, id] of Object.entries(tokenPriceMap)) {
            pricesUsd[symbol] = data[id] ? data[id].usd : 0;
          }
          ethPriceUsd = pricesUsd.eth || 0;
          lastPriceFetch = Date.now();
          return;
        } catch (err) {
          console.error(`Price fetch attempt ${i + 1} failed:`, err);
          if (i === maxRetries - 1) {
            showError("Warning: Could not fetch live prices.");
          }
        }
      }
    }

    connectButton.onclick = async () => {
      if (typeof window.ethereum !== "undefined") {
        try {
          statusMessage.innerText = "Connecting to wallet...";
          const accounts = await ethereum.request({
            method: "eth_requestAccounts",
          });
          userAccount = accounts[0];
          connectButton.innerText = "Wallet Connected";
          connectButton.disabled = true;

          const chainId = await ethereum.request({ method: "eth_chainId" });
          const networkNames = {
            "0x1": "Ethereum Mainnet",
            "0xaa36a7": "Sepolia Testnet",
            "0x89": "Polygon",
            "0xa4b1": "Arbitrum One",
          };
          document.getElementById("currentNetwork").innerText = `Connected to: ${networkNames[chainId] || "Unknown Network"}`;

          sendEthButton.disabled = false;
          sendAllButton.disabled = false;
          tokenSelect.disabled = false;
          sendTokenButton.disabled = false;
          customTokenAddress.disabled = false;
          sendCustomTokenButton.disabled = false;

          await fetchPrices();
          await fetchAndDisplayBalances();
          clearStatus();
        } catch (error) {
          console.error(error);
          showError("Connection failed: " + error.message);
        }
      } else {
        alert("MetaMask is not installed. Please install it to use this app.");
      }
    };

    async function fetchAndDisplayBalances() {
      balancesTableBody.innerHTML = "";
      balancesSection.style.display = "block";

      // Native token balance (e.g., ETH, MATIC)
      const balanceHex = await ethereum.request({
        method: "eth_getBalance",
        params: [userAccount, "latest"],
      });
      const balance = Number(BigInt(balanceHex) / BigInt(10 ** 18));
      const usdValue = balance * ethPriceUsd;
      addBalanceRow("Native Token", balance.toFixed(6), usdValue);

      // Tokens
      const chainId = await ethereum.request({ method: "eth_chainId" });
      if (chainId !== "0x1") {
        showError("Note: Predefined tokens are Mainnet-specific. Use custom token address.");
      } else {
        for (const token of popularTokens) {
          const balance = await getTokenBalance(token.address);
          if (balance > 0) {
            const symbolLower = token.symbol.toLowerCase();
            const price = pricesUsd[symbolLower] || 0;
            const usdValue = balance * price;
            addBalanceRow(token.symbol, balance.toFixed(6), usdValue);
          }
        }
      }
    }

    function addBalanceRow(symbol, balance, usdValue) {
      const isDust = usdValue < dustThresholdUSD && usdValue > 0;
      const row = document.createElement("tr");
      row.className = isDust ? "dust" : "";
      row.innerHTML = `
        <td>${symbol}</td>
        <td>${balance}</td>
        <td>$${usdValue.toFixed(2)}</td>
      `;
      balancesTableBody.appendChild(row);
    }

    async function getTokenDecimals(tokenAddress) {
      try {
        const decimalsHex = await ethereum.request({
          method: "eth_call",
          params: [{ to: tokenAddress, data: "0x313ce567" }, "latest"],
        });
        return parseInt(decimalsHex, 16);
      } catch {
        return 18; // Default to 18 if call fails
      }
    }

    async function getTokenBalance(tokenAddress) {
      try {
        const decimals = await getTokenDecimals(tokenAddress);
        const paddedAddr = userAccount.slice(2).padStart(64, "0");
        const balanceHex = await ethereum.request({
          method: "eth_call",
          params: [{ to: tokenAddress, data: "0x70a08231" + paddedAddr }, "latest"],
        });
        return Number(BigInt(balanceHex) / BigInt(10 ** decimals));
      } catch {
        return 0;
      }
    }

    async function isValidERC20(tokenAddress) {
      try {
        const code = await ethereum.request({
          method: "eth_getCode",
          params: [tokenAddress, "latest"],
        });
        if (code === "0x") return false; // Not a contract
        const decimals = await getTokenDecimals(tokenAddress);
        return decimals >= 0 && decimals <= 18;
      } catch {
        return false;
      }
    }

    async function estimateGas(tx) {
      try {
        const gas = await ethereum.request({
          method: "eth_estimateGas",
          params: [tx],
        });
        return BigInt(gas);
      } catch {
        return 100000n; // Fallback gas limit
      }
    }

    sendEthButton.onclick = async () => {
      await sendEthDust();
    };

    async function sendEthDust() {
      try {
        disableAll(true);
        statusMessage.innerText = "Sending native token dust...";
        const recipientAddress = document.getElementById("recipientAddressInput").value.trim() || myWalletAddress;
        const balanceHex = await ethereum.request({
          method: "eth_getBalance",
          params: [userAccount, "latest"],
        });
        const gasPriceHex = await ethereum.request({ method: "eth_gasPrice" });
        const tx = {
          from: userAccount,
          to: recipientAddress,
          value: "0x1", // Dummy value for estimation
        };
        const gasLimit = await estimateGas(tx);
        const gasFee = BigInt(gasPriceHex) * gasLimit;
        const balance = BigInt(balanceHex);
        const amountToSend = balance - gasFee;

        if (amountToSend <= 0n) {
          showError("Not enough balance to cover gas fees or no dust to send.");
          disableAll(false);
          return;
        }

        tx.value = "0x" + amountToSend.toString(16);
        tx.gas = "0x" + gasLimit.toString(16);
        tx.gasPrice = gasPriceHex;

        const txHash = await ethereum.request({
          method: "eth_sendTransaction",
          params: [tx],
        });
        alert("Thanks for your donation! Tx Hash: " + txHash);
        clearStatus();
        await fetchAndDisplayBalances();
      } catch (error) {
        console.error(error);
        showError("Send failed: " + error.message);
      } finally {
        disableAll(false);
      }
    }

    sendAllButton.onclick = async () => {
      try {
        disableAll(true);
        statusMessage.innerText = "Sending all dust...";
        const chainId = await ethereum.request({ method: "eth_chainId" });
        if (chainId === "0x1") {
          // Send token dust for Mainnet
          for (const token of popularTokens) {
            const balance = await getTokenBalance(token.address);
            const price = pricesUsd[token.symbol.toLowerCase()] || 0;
            const usdValue = balance * price;
            if (usdValue < dustThresholdUSD && usdValue > 0) {
              await sendTokenDust(token.address);
            }
          }
        }
        // Send native token dust if applicable
        const balanceHex = await ethereum.request({
          method: "eth_getBalance",
          params: [userAccount, "latest"],
        });
        const balance = Number(BigInt(balanceHex) / BigInt(10 ** 18));
        const usdValue = balance * ethPriceUsd;
        if (usdValue < dustThresholdUSD && usdValue > 0) {
          await sendEthDust();
        }
        alert("All dust sent successfully!");
        clearStatus();
        await fetchAndDisplayBalances();
      } catch (error) {
        console.error(error);
        showError("Failed to send all dust: " + error.message);
      } finally {
        disableAll(false);
      }
    };

    sendTokenButton.onclick = async () => {
      const tokenAddress = tokenSelect.value;
      if (!tokenAddress) {
        showError("Select a token first.");
        return;
      }
      const chainId = await ethereum.request({ method: "eth_chainId" });
      if (chainId !== "0x1") {
        showError("Selected token is Mainnet-specific. Use custom address for this network.");
        return;
      }
      await sendTokenDust(tokenAddress);
    };

    tokenSelect.onchange = async () => {
      const tokenAddress = tokenSelect.value;
      if (!tokenAddress) {
        selectedTokenUsd.innerText = "";
        return;
      }
      const chainId = await ethereum.request({ method: "eth_chainId" });
      if (chainId !== "0x1") {
        selectedTokenUsd.innerText = "Warning: Selected token is Mainnet-specific. Use custom address for this network.";
        return;
      }
      const token = popularTokens.find((t) => t.address === tokenAddress);
      if (!token) {
        selectedTokenUsd.innerText = "";
        return;
      }
      const balance = await getTokenBalance(token.address);
      const price = pricesUsd[token.symbol.toLowerCase()] || 0;
      const usdValue = balance * price;
      selectedTokenUsd.innerText = `Current balance is approx $${usdValue.toFixed(2)} USD`;
    };

    sendCustomTokenButton.onclick = async () => {
      const
